Go 字符串不是严格意义上的 copy-on-write，但它的底层实现有一些优化让它表现得类似于“轻量拷贝”。我们仔细分析一下：

1. 字符串的内部结构

在 Go 中，字符串是一个 不可变类型：

type stringHeader struct {
    Data uintptr // 底层指向字节数组的指针
    Len  int
}


Data 指向底层的字节数组

Len 是长度

字符串是 只读的，不能修改内容

2. 拷贝字符串变量的开销

当你执行：

s1 := "hello world"
s2 := s1


并不会拷贝底层字节数组

只是拷贝了 stringHeader（16 字节左右）

两个字符串变量指向同一块底层数据

✅ 这就是为什么拷贝字符串很快

3. 修改字符串会发生什么？

Go 的字符串不可变

所以如果你尝试“修改”，只能通过创建新的字符串

例如：

s3 := s1 + "!!!"


会创建一个新的底层数组，拷贝原来的内容 + 新内容

原来的底层数组不受影响

4. 是否算 copy-on-write？

严格来说：

不是操作系统层面的 COW

不是自动延迟拷贝到写时才拷贝

Go 的字符串只是 不可变值类型 + 指向共享底层数组

写操作本身就会创建新的拷贝

所以表现类似 COW，但机制不同。

✅ 总结
特性	Go 字符串
拷贝变量开销	很小，只拷贝 header
修改内容	总会生成新底层数组
底层共享	读操作共享底层数组
真正 COW	否，写时一定会新分配
