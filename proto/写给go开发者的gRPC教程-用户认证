æœ¬ç¯‡ä¸ºã€å†™ç»™goå¼€å‘è€…çš„gRPCæ•™ç¨‹ã€‘ç³»åˆ—ç¬¬å…«ç¯‡
ç¬¬ä¸€ç¯‡ï¼šprotobufåŸºç¡€
ç¬¬äºŒç¯‡ï¼šé€šä¿¡æ¨¡å¼
ç¬¬ä¸‰ç¯‡ï¼šæ‹¦æˆªå™¨
ç¬¬å››ç¯‡ï¼šé”™è¯¯å¤„ç†
ç¬¬äº”ç¯‡ï¼šmetadata
ç¬¬å…­ç¯‡ï¼šè¶…æ—¶æ§åˆ¶
ç¬¬ä¸ƒç¯‡ï¼šå®‰å…¨
ç¬¬å…«ç¯‡ï¼šç”¨æˆ·è®¤è¯ ğŸ‘ˆ
æœ¬ç³»åˆ—å°†æŒç»­æ›´æ–°ï¼Œæ¬¢è¿å…³æ³¨ ğŸ‘ è·å–å®æ—¶é€šçŸ¥

gRPCçš„ç”¨æˆ·è®¤è¯
ç”¨æˆ·è®¤è¯ï¼Œç®€å•æ¥è¯´å°±æ˜¯éªŒè¯è¯·æ±‚çš„ç”¨æˆ·èº«ä»½ï¼Œé¿å…ç ´åè€…ä¼ªé€ èº«ä»½è·å–ä»–äººæ•°æ®éšç§ã€‚æ¯”å¦‚å½“è®¿é—®å¾®åšç½‘ç«™æ—¶ï¼Œå¾®åšæœåŠ¡ç«¯é€šè¿‡ç”¨æˆ·è®¤è¯æ¥è¯†åˆ«ä½ çš„èº«ä»½ï¼Œå¹¶è¿”å›æ­£ç¡®çš„ä¸»é¡µæ•°æ®
ç”¨æˆ·è®¤è¯æœ‰å¾ˆå¤šæ–¹å¼ã€‚ä¾‹å¦‚HTTPä¸­ä½¿ç”¨çš„cookieã€sessionã€oauthã€jwtç­‰ç­‰ã€‚gRPCæ¡†æ¶å¹¶ä¸é™åˆ¶ç”¨æˆ·è®¤è¯çš„æ–¹å¼ï¼Œè€Œæ˜¯æä¾›äº†å¼€æ”¾çš„èƒ½åŠ›æ¥æ”¯æŒå„ç§å„æ ·çš„ç”¨æˆ·è®¤è¯
gRPCçš„ç”¨æˆ·è®¤è¯å¯ä»¥ç”¨ä¸¤å¥è¯æ€»ç»“


gRPCå®¢æˆ·ç«¯æä¾›åœ¨æ¯ä¸€æ¬¡è°ƒç”¨æ³¨å…¥ç”¨æˆ·å‡­è¯çš„èƒ½åŠ›


gRPCæœåŠ¡ç«¯ä½¿ç”¨æ‹¦æˆªå™¨æ¥éªŒè¯æ¯ä¸€ä¸ªå®¢æˆ·ç«¯çš„è¯·æ±‚


è¦å®ç°åœ¨æ¯ä¸€æ¬¡è°ƒç”¨æ³¨å…¥ç”¨æˆ·å‡­è¯çš„èƒ½åŠ›ï¼Œæˆ‘ä»¬éœ€è¦å®ç°credentials.PerRPCCredentialsæ¥å£ï¼Œå¹¶ä¸”åœ¨å®¢æˆ·ç«¯åˆ›å»ºé“¾æ¥çš„æ—¶å€™æŒ‡å®šgrpc.WithPerRPCCredentials(credentials.PerRPCCredentials)
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç type PerRPCCredentials interface {
	// GetRequestMetadata è·å–å½“å‰è¯·æ±‚çš„metadata
	GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
	// RequireTransportSecurity æ˜¯å¦ä½¿ç”¨å®‰å…¨çš„ä¼ è¾“åè®®
	RequireTransportSecurity() bool
}

è¦éªŒè¯æ¯ä¸€ä¸ªå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°å‰å‡ æœŸæåˆ°çš„æ‹¦æˆªå™¨ï¼šå†™ç»™goå¼€å‘è€…çš„gRPCæ•™ç¨‹-æ‹¦æˆªå™¨

ä¸‹é¢æˆ‘ä»¬æ¥ä»‹ç»åœ¨gRPCä¸­ä½¿ç”¨æ¯”è¾ƒå¸¸è§çš„ä¸¤ç§è®¤è¯æ–¹å¼ï¼šBasic Authenticationå’ŒJWT
Basic Authentication
Basic Authenticationæ˜¯æœ€ç®€å•çš„è®¤è¯æ–¹å¼

ä½¿ç”¨Basic Authenticationæ—¶ï¼Œå®¢æˆ·ç«¯æºå¸¦ä¸€ä¸ªAuthorization headerå¤´ï¼Œå€¼ä¸ºBasic + ç©ºæ ¼ + base64ç¼–ç çš„ç”¨æˆ·å:å¯†ç 
ä¾‹å¦‚ä¸€ä¸ªç”¨æˆ·åå’Œå¯†ç éƒ½æ˜¯adminï¼Œé‚£ä¹ˆheaderå¤´å¦‚ä¸‹
text ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç Authorization: Basic YWRtaW46YWRtaW4=


é€šå¸¸å¹¶ä¸æ¨èä½¿ç”¨Basic Authenticationï¼ŒgRPCä¹Ÿæ²¡æœ‰å†…ç½®ç»„ä»¶æ”¯æŒï¼Œä½†åœ¨gRPCä¸­å¾ˆå®¹æ˜“åšåˆ°ã€‚
å®¢æˆ·ç«¯ä»£ç 
æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªç»“æ„ä½“BasicAuthenticationå¹¶è®©å®ƒå®ç°credentials.PerRPCCredentialsæ¥å£ï¼Œå°±å¯ä»¥æŠŠç”¨æˆ·å‡­è¯æ·»åŠ åˆ°å®¢æˆ·ç«¯çš„ä¸Šä¸‹æ–‡ä¸­
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç type PerRPCCredentials interface {
	// GetRequestMetadata è·å–å½“å‰è¯·æ±‚çš„metadata
	GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
	// RequireTransportSecurity æ˜¯å¦ä½¿ç”¨å®‰å…¨çš„ä¼ è¾“åè®®
	RequireTransportSecurity() bool
}

go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç var _ credentials.PerRPCCredentials = BasicAuthentication{}

type BasicAuthentication struct {
	password string
	username string
}

func (b BasicAuthentication) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	auth := b.username + ":" + b.password
	enc := base64.StdEncoding.EncodeToString([]byte(auth))

	return map[string]string{
		"authorization": "Basic " + enc,
	}, nil
}

func (b BasicAuthentication) RequireTransportSecurity() bool {
	return true
}

åœ¨åˆ›å»ºè¿æ¥æ—¶ä½¿ç”¨grpc.WithPerRPCCredentials(auth)è®¾ç½®æ¯ä¸€æ¬¡è¯·æ±‚çš„ç”¨æˆ·å‡­è¯
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç func main() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	auth := BasicAuthentication{
		username: "admin",
		password: "admin",
	}

	creds, err := credentials.NewClientTLSFromFile("./x509/rootCa.crt", "www.example.com")
	if err != nil {
		panic(err)
	}

	conn, err := grpc.Dial("localhost:8009",
		grpc.WithTransportCredentials(creds),
		grpc.WithPerRPCCredentials(auth))
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	client := pb.NewOrderManagementClient(conn)

	// Get Order
	retrievedOrder, err := client.GetOrder(ctx, &wrapperspb.StringValue{Value: "101"})
	if err != nil {
		panic(err)
	}

	log.Print("GetOrder Response -> : ", retrievedOrder)
}

âš ï¸ æ³¨æ„
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç type PerRPCCredentials interface {
	// GetRequestMetadata è·å–å½“å‰è¯·æ±‚çš„metadata
	GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
	// RequireTransportSecurity æ˜¯å¦ä½¿ç”¨å®‰å…¨çš„ä¼ è¾“åè®®
	RequireTransportSecurity() bool
}

RequireTransportSecurity()ä»£è¡¨æ˜¯å¦ä½¿ç”¨å®‰å…¨çš„ä¼ è¾“åè®®ã€‚å¦‚æœè®¾ç½®äº†trueï¼Œåˆ™å¿…é¡»é€šè¿‡grpc.WithTransportCredentials()è®¾ç½®åˆç†çš„ä¼ è¾“å±‚åŠ å¯†æ–¹å¼ï¼Œå¦åˆ™ä¼šå¯¼è‡´å»ºç«‹è¿æ¥æ—¶å¤±è´¥
gRPCå®˜æ–¹åº“é‡Œæœ‰ä¸ªinsecure.NewCredentials()ï¼Œè¿™æ®µå‡½æ•°å«ä¹‰ä¸ºç¦ç”¨ä¼ è¾“å±‚å®‰å…¨åè®®ï¼Œå› æ­¤grpc.WithTransportCredentials(insecure.NewCredentials())æ˜¯æ— æ•ˆçš„ï¼Œä¾æ—§ä¼šå¯¼è‡´å»ºç«‹è¿æ¥æ—¶å¤±è´¥
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç auth := BasicAuthentication{
    username: "admin",
    password: "admin",
}

conn, err := grpc.Dial("localhost:8009",
                       grpc.WithTransportCredentials(insecure.NewCredentials()),
                       grpc.WithPerRPCCredentials(auth))
if err != nil {
    panic(err)
}

go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç $ go run basic-authentication/client/main.go
panic: grpc: the credentials require transport level security (use grpc.WithTransportCredentials() to set)

æœåŠ¡ç«¯ä»£ç 
æœåŠ¡ç«¯ä½¿ç”¨æ‹¦æˆªå™¨æ¥éªŒè¯è¯·æ±‚æ˜¯å¦åˆæ³•
å¯¹äºä¸åˆæ³•çš„tokenè¿”å›codes.Unauthenticated
å¦‚æœtokenåˆæ³•ï¼Œåœ¨ensureValidBasicCredentialsä¸­è°ƒç”¨handleræ¥ç»§ç»­è¯·æ±‚çš„å¤„ç†
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç var (
	errMissingMetadata = status.Errorf(codes.InvalidArgument, "missing metadata")
	errInvalidToken    = status.Errorf(codes.Unauthenticated, "invalid credentials")
)

func ensureValidBasicCredentials(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errMissingMetadata
	}

	authorization := md["authorization"]

	if len(authorization) < 1 {
		return nil, errInvalidToken
	}

	token := strings.TrimPrefix(authorization[0], "Basic ")
	if token != base64.StdEncoding.EncodeToString([]byte("admin:admin")) {
		return nil, errInvalidToken
	}

	return handler(ctx, req)
}

func main() {
	l, err := net.Listen("tcp", ":8009")
	if err != nil {
		panic(err)
	}

	creds, err := credentials.NewServerTLSFromFile("./x509/server.crt", "./x509/server.key")
	s := grpc.NewServer(
		grpc.UnaryInterceptor(ensureValidBasicCredentials),
		grpc.Creds(creds),
	)

	pb.RegisterOrderManagementServer(s, &server{})

	if err := s.Serve(l); err != nil {
		panic(err)
	}
}

JWT
å…³äºjwtçš„ä»‹ç»å‚è€ƒï¼šJSON Web Token å…¥é—¨æ•™ç¨‹
è¿™é‡Œç®€è¿°å¦‚ä¸‹


å®¢æˆ·ç«¯è¿›è¡Œç™»é™†æ“ä½œ


æœåŠ¡å™¨è®¤è¯ä»¥åï¼Œç”Ÿæˆä¸€ä¸ª JWT å­—ç¬¦ä¸²ï¼Œå‘å›ç»™ç”¨æˆ·
JWT ä¸­é—´ç”¨ç‚¹ï¼ˆ.ï¼‰åˆ†éš”æˆä¸‰ä¸ªéƒ¨åˆ†
tex ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç Header.Payload.Signature






å®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡å™¨è¿”å›çš„ JWTï¼Œå¯ä»¥å‚¨å­˜åœ¨ Cookie é‡Œé¢ï¼Œä¹Ÿå¯ä»¥å‚¨å­˜åœ¨ localStorage


æ­¤åï¼Œå®¢æˆ·ç«¯æ¯æ¬¡ä¸æœåŠ¡å™¨é€šä¿¡ï¼Œéƒ½è¦å¸¦ä¸Šè¿™ä¸ª JWTã€‚ä½ å¯ä»¥æŠŠå®ƒæ”¾åœ¨ Cookie é‡Œé¢è‡ªåŠ¨å‘é€ï¼Œä½†æ˜¯è¿™æ ·ä¸èƒ½è·¨åŸŸï¼Œæ‰€ä»¥æ›´å¥½çš„åšæ³•æ˜¯æ”¾åœ¨ HTTP è¯·æ±‚çš„å¤´ä¿¡æ¯Authorizationå­—æ®µé‡Œé¢
html ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç Authorization: Bearer <token>



æœåŠ¡å™¨ä¼šæ ¡éªŒç­¾åï¼Œå¯¹è¿™ä¸ªå¯¹è±¡è®¤å®šç”¨æˆ·èº«ä»½


gRPCæä¾›çš„jwt
æ•´ä¸ªgRPCæˆ–è€…è¯´è°·æ­Œgolangç”Ÿæ€æä¾›çš„jwtåŒ…å¾ˆæ··ä¹±
å¦‚æœä¸æƒ³äº†è§£ç»†èŠ‚ç›´æ¥çœ‹ç»“è®ºï¼šä¸èƒ½ç”¨golang.org/x/oauth2å®ç°æˆ‘ä»¬å¸¸è§„æ„ä¹‰ä¸Šçš„jwtåŠŸèƒ½ï¼Œè™½ç„¶è¿™ä¸ªåŒ…é‡Œæœ‰å„å¼å„æ ·çš„å«æœ‰jwtå­—æ ·çš„å‡½æ•°
ä¸‹é¢æ˜¯è¯¦ç»†æ¢³ç†
golang.org/x/oauth2 åŒ…å«å¸¸è§å¹³å°å¦‚è°·æ­Œï¼Œäºšé©¬é€Šç­‰oauth2çš„è®¤è¯åŠŸèƒ½
âš ï¸ golang.org/x/oauth2/goâ€¦
è¿™ä¸ªåŒ…ä¸“é—¨æä¾›è°·æ­Œapiçš„è®¤è¯åŠŸèƒ½ï¼Œå®ƒä½¿ç”¨äº†è°·æ­Œçš„serviceaccountçš„jsonæ–‡ä»¶ä½œä¸ºç”¨æˆ·å‡­è¯
ä½†è¿™ä¸ªåŒ…ä¸æ˜¯oauth2çš„æ ‡å‡†æµç¨‹ï¼Œè€Œæ˜¯åˆ›å»ºjwtä½œä¸ºoauth2çš„access tokenã€‚å®ƒä½œä¸ºä¸€ç§ä¼˜åŒ–çš„è®¤è¯æ–¹å¼è¢«éƒ¨åˆ†è°·æ­Œçš„æœåŠ¡æ”¯æŒã€‚è¿™éƒ¨åˆ†è¯´æ˜å¯ä»¥å‚è€ƒï¼šdevelopers.google.com/identity/prâ€¦
âš ï¸ golang.org/x/oauth2/jwâ€¦
è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„jwt oauth2.0 çš„æµç¨‹ï¼Œå®ƒçš„äº¤äº’å¯ä»¥å‚è€ƒè°·æ­Œæ–‡æ¡£ï¼Œå®ƒèƒ½æ”¯æŒæ‰€æœ‰two-legged oauth2.0çš„æœåŠ¡ï¼Œä¸ä»…é™äºè°·æ­Œçš„æœåŠ¡
ä½†å®ƒä¸æ˜¯æˆ‘ä»¬å¸¸è§„è®¤ä¸ºçš„jwtï¼Œè€Œæ˜¯ä½¿ç”¨jwtä½œä¸ºoauth2.0çš„ä¸€ç¯

âš ï¸ google.golang.org/grpc/credenâ€¦
å®ƒä½¿ç”¨ golang.org/x/oauth2/google æ¥å®ç°gRPCçš„credentials.PerRPCCredentialsï¼Œä¹Ÿå°±æ„å‘³ç€å®ƒä¸»è¦ç”¨ä½œè®¿é—®è°·æ­ŒæœåŠ¡çš„è®¤è¯
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç import (
	"context"
	"log"
	"time"

	pb "github.com/liangwt/note/grpc/authentication/ecommerce"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/oauth"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	jwtAuth, err := oauth.NewJWTAccessFromFile("./x509/winged-axon-372312-154a8b3aa89d.json")
	if err != nil {
		panic(err)
	}

	creds, err := credentials.NewClientTLSFromFile("./x509/rootCa.crt", "www.example.com")
	if err != nil {
		panic(err)
	}

	conn, err := grpc.Dial("localhost:8009",
		grpc.WithTransportCredentials(creds),
		grpc.WithPerRPCCredentials(jwtAuth))
	if err != nil {
		panic(err)
	}
  // ...
}

ä¸‰ä¸ªåŒ…çš„å…³ç³»å¦‚ä¸‹

è‡ªå®šä¹‰çš„jwt
ä¸Šæ–‡è¯´äº†golang.org/x/oauth2ä¸èƒ½ç”¨
è‡ªå®šä¹‰å®ç°jwtå¯ä»¥ä½¿ç”¨github.com/golang-jwt/â€¦åº“
å®¢æˆ·ç«¯ä»£ç 
å®¢æˆ·ç«¯çš„tokenåº”è¯¥æ˜¯ç”±æœåŠ¡ç«¯è¿”å›çš„ï¼Œè€Œä¸æ˜¯å®¢æˆ·ç«¯è‡ªå·±ç”Ÿæˆçš„ï¼Œè¿™é‡Œåªæ˜¯ä¸ºäº†æ–¹ä¾¿æ¼”ç¤º
ä¸»è¦é€»è¾‘æ˜¯å£°æ˜claimsç„¶åä½¿ç”¨secret keyè¿›è¡Œç­¾å
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç package main

import (
	"context"
	"log"
	"time"

	"github.com/golang-jwt/jwt/v4"
	pb "github.com/liangwt/note/grpc/authentication/ecommerce"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

var _ credentials.PerRPCCredentials = JwtAuthentication{}

type JwtAuthentication struct {
	Key []byte
}

func (a JwtAuthentication) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	// Create a new token object, specifying signing method and the claims
	// you would like it to contain.
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.RegisteredClaims{
		ID:        "example",
		ExpiresAt: jwt.NewNumericDate(time.Now().Add(-2 * time.Hour)),
	})

	// Sign and get the complete encoded token as a string using the secret
	tokenString, err := token.SignedString(a.Key)
	if err != nil {
		return nil, err
	}

	return map[string]string{
		"authorization": "Bearer " + tokenString,
	}, nil
}

func (b JwtAuthentication) RequireTransportSecurity() bool {
	return true
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	creds, err := credentials.NewClientTLSFromFile("./x509/rootCa.crt", "www.example.com")
	if err != nil {
		panic(err)
	}

	jwtAuth := JwtAuthentication{[]byte("154a8b3aa89d3d4c49826f6dbbbe5542b5a9fbbb")}

	conn, err := grpc.Dial("localhost:8009",
		grpc.WithTransportCredentials(creds),
		grpc.WithPerRPCCredentials(jwtAuth))
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	client := pb.NewOrderManagementClient(conn)

	// Get Order
	retrievedOrder, err := client.GetOrder(ctx, &wrapperspb.StringValue{Value: "101"})
	if err != nil {
		panic(err)
	}

	log.Printf("GetOrder Response -> : %+v\n", retrievedOrder)
}


æœåŠ¡ç«¯ä»£ç 
æœåŠ¡ç«¯ä»£ç ä½¿ç”¨æ‹¦æˆªå™¨ï¼Œæ¥å¯¹jwtè¿›è¡ŒéªŒè¯
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç package main

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/golang-jwt/jwt/v4"
	pb "github.com/liangwt/note/grpc/authentication/ecommerce"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

var (
	errMissingMetadata = status.Errorf(codes.InvalidArgument, "missing metadata")
)

func ensureValidBasicCredentials(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errMissingMetadata
	}

	tokenString := strings.TrimPrefix(md["authorization"][0], "Bearer ")

	token, err := jwt.ParseWithClaims(tokenString, &jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) {
		// Don't forget to validate the alg is what you expect:
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
		}

		return []byte("154a8b3aa89d3d4c49826f6dbbbe5542b5a9fbbb"), nil
	})

	claims, ok := token.Claims.(*jwt.RegisteredClaims)
	if !ok || !token.Valid {
		return nil, status.Errorf(codes.Unauthenticated, err.Error())
	}

	fmt.Println(claims.ID)

	return handler(ctx, req)
}

func main() {
	l, err := net.Listen("tcp", ":8009")
	if err != nil {
		panic(err)
	}

	creds, err := credentials.NewServerTLSFromFile("./x509/server.crt", "./x509/server.key")
	s := grpc.NewServer(
		grpc.UnaryInterceptor(ensureValidBasicCredentials),
		grpc.Creds(creds),
	)

	pb.RegisterOrderManagementServer(s, &server{})

	if err := s.Serve(l); err != nil {
		panic(err)
	}
}

æ€»ç»“
ğŸŒ² gRPCå¯ä»¥æ”¯æŒå„ç§å„æ ·çš„ç”¨æˆ·è®¤è¯
gRPCå®¢æˆ·ç«¯æä¾›åœ¨æ¯ä¸€æ¬¡è°ƒç”¨æ³¨å…¥ç”¨æˆ·å‡­è¯çš„èƒ½åŠ›
æˆ‘ä»¬éœ€è¦å®ç°credentials.PerRPCCredentialsæ¥å£ï¼Œå¹¶ä¸”åœ¨å®¢æˆ·ç«¯åˆ›å»ºé“¾æ¥çš„æ—¶å€™æŒ‡å®šgrpc.WithPerRPCCredentials(credentials.PerRPCCredentials)
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç type PerRPCCredentials interface {
	// GetRequestMetadata è·å–å½“å‰è¯·æ±‚çš„metadata
	GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
	// RequireTransportSecurity æ˜¯å¦ä½¿ç”¨å®‰å…¨çš„ä¼ è¾“åè®®
	RequireTransportSecurity() bool
}

gRPCæœåŠ¡ç«¯ä½¿ç”¨æ‹¦æˆªå™¨æ¥éªŒè¯æ¯ä¸€ä¸ªå®¢æˆ·ç«¯çš„è¯·æ±‚
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)

s := grpc.NewServer(
    grpc.UnaryInterceptor(UnaryServerInterceptor),
)

åˆ©ç”¨ä»¥ä¸Šä¸¤ä¸ªç‰¹æ€§ï¼ŒgRPCå¯ä»¥æ”¯æŒå„ç§å„æ ·çš„ç”¨æˆ·è®¤è¯
ğŸŒ² ä¼ è¾“å±‚åŠ å¯†
å®ç°grpc.WithPerRPCCredentials()æ—¶RequireTransportSecurityå¦‚æœè®¾ç½®äº†trueï¼Œåˆ™å¿…é¡»è®¾ç½®åˆç†çš„ä¼ è¾“å±‚åŠ å¯†æ–¹å¼ï¼ˆgrpc.WithTransportCredentials()ï¼‰ï¼Œå¦åˆ™ä¼šå¯¼è‡´å»ºç«‹è¿æ¥æ—¶å¤±è´¥
ğŸŒ² gRPCä¸­çš„jwtè®¤è¯
è‡ªå®šä¹‰å®ç°jwtæ¨èä½¿ç”¨github.com/golang-jwt/â€¦åº“ï¼Œgolang.org/x/oauth2/jwâ€¦ä¸æ˜¯ä¸€ä¸ªæˆ‘ä»¬å¸¸è§„ç†è§£çš„jwtåº“


ä½œè€…ï¼šå‡‰å‡‰çš„çŸ¥è¯†åº“
é“¾æ¥ï¼šhttps://juejin.cn/post/7229145941399027771
æ¥æºï¼šç¨€åœŸæ˜é‡‘
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
