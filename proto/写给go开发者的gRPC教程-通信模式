æœ¬ç¯‡ä¸ºã€å†™ç»™goå¼€å‘è€…çš„gRPCæ•™ç¨‹ã€‘ç³»åˆ—ç¬¬äºŒç¯‡
ç¬¬ä¸€ç¯‡ï¼šprotobufåŸºç¡€
ç¬¬äºŒç¯‡ï¼šé€šä¿¡æ¨¡å¼ ğŸ‘ˆ
ç¬¬ä¸‰ç¯‡ï¼šæ‹¦æˆªå™¨
ç¬¬å››ç¯‡ï¼šé”™è¯¯å¤„ç†
ç¬¬äº”ç¯‡ï¼šmetadata
ç¬¬å…­ç¯‡ï¼šè¶…æ—¶æ§åˆ¶
ç¬¬ä¸ƒç¯‡ï¼šå®‰å…¨
ç¬¬å…«ç¯‡ï¼šç”¨æˆ·è®¤è¯
ç¬¬ä¹ç¯‡ï¼šæœåŠ¡å‘ç°ä¸è´Ÿè½½å‡è¡¡

ä¸Šä¸€ç¯‡ä»‹ç»äº†å¦‚ä½•ç¼–å†™ protobuf çš„ idlï¼Œå¹¶ä½¿ç”¨ idl ç”Ÿæˆäº† gRPC çš„ä»£ç ï¼Œç°åœ¨æ¥çœ‹çœ‹å¦‚ä½•ç¼–å†™å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çš„ä»£ç 
Simple RPC (Unary RPC)
protobuf ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç syntax = "proto3";

package ecommerce;

import "google/protobuf/wrappers.proto";

option go_package = "ecommerce/";

message Order {
  string id = 1;
  repeated string items = 2;
  string description = 3;
  float price = 4;
  string destination = 5;
}

service OrderManagement {
  rpc getOrder(google.protobuf.StringValue) returns (Order);
}

å®šä¹‰å¦‚ä¸Šçš„ idlï¼Œéœ€è¦å…³æ³¨å‡ ä¸ªäº‹é¡¹

ä½¿ç”¨protobufæœ€æ–°ç‰ˆæœ¬syntax = "proto3";
protoc-gen-goè¦æ±‚ pb æ–‡ä»¶å¿…é¡»æŒ‡å®š go åŒ…çš„è·¯å¾„ã€‚å³option go_package = "ecommerce/";
å®šä¹‰çš„methodä»…èƒ½æœ‰ä¸€ä¸ªå…¥å‚å’Œå‡ºå‚æ•°ã€‚å¦‚æœéœ€è¦ä¼ é€’å¤šä¸ªå‚æ•°éœ€è¦å®šä¹‰æˆmessage
ä½¿ç”¨importå¼•ç”¨å¦å¤–ä¸€ä¸ªæ–‡ä»¶çš„ pbã€‚google/protobuf/wrappers.protoæ˜¯ google å†…ç½®çš„ç±»å‹

ç”Ÿæˆ go å’Œ grpc çš„ä»£ç 
shell ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç $ protoc -I ./pb \
  --go_out ./ecommerce --go_opt paths=source_relative \
  --go-grpc_out ./ecommerce --go-grpc_opt paths=source_relative \
  ./pb/product.proto

shell ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç ecommerce
â”œâ”€â”€ product.pb.go
â””â”€â”€ product_grpc.pb.go
pb
â””â”€â”€ product.proto

server å®ç°
1ã€ç”± pb æ–‡ä»¶ç”Ÿæˆçš„ gRPC ä»£ç ä¸­åŒ…å«äº† service çš„æ¥å£å®šä¹‰ï¼Œå®ƒå’Œæˆ‘ä»¬å®šä¹‰çš„ idl æ˜¯å»åˆçš„
protobuf ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç service OrderManagement {
  rpc getOrder(google.protobuf.StringValue) returns (Order);
}

go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç type OrderManagementServer interface {
	GetOrder(context.Context, *wrapperspb.StringValue) (*Order, error)
	mustEmbedUnimplementedOrderManagementServer()
}

2ã€æˆ‘ä»¬çš„ä¸šåŠ¡é€»è¾‘å°±æ˜¯å®ç°è¿™ä¸ªæ¥å£
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç package main

import (
	"context"
	"log"

	pb "github.com/liangwt/note/grpc/unary_rpc_example/ecommerce"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

var _ pb.OrderManagementServer = &OrderManagementImpl{}

var orders = make(map[string]pb.Order)

type OrderManagementImpl struct {
	pb.UnimplementedOrderManagementServer
}

// Simple RPC
func (s *OrderManagementImpl) GetOrder(ctx context.Context, orderId *wrapperspb.StringValue) (*pb.Order, error) {
	ord, exists := orders[orderId.Value]
	if exists {
		return &ord, status.New(codes.OK, "").Err()
	}

	return nil, status.Errorf(codes.NotFound, "Order does not exist. : ", orderId)
}

3ã€åœ¨å®ç°å®Œä¸šåŠ¡é€»è¾‘ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºå¹¶å¯åŠ¨æœåŠ¡
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç package main

import (
	"net"

	pb "github.com/liangwt/note/grpc/unary_rpc_example/ecommerce"
	"google.golang.org/grpc"
)

func main() {
	s := grpc.NewServer()

	pb.RegisterOrderManagementServer(s, &OrderManagementImpl{})

	lis, err := net.Listen("tcp", ":8009")
	if err != nil {
		panic(err)
	}

	if err := s.Serve(lis); err != nil {
		panic(err)
	}
}

æœåŠ¡ç«¯ä»£ç å®ç°çš„æµç¨‹å¦‚ä¸‹

client å®ç°
1ã€ç”± pb æ–‡ä»¶ç”Ÿæˆçš„ gRPC ä»£ç ä¸­åŒ…å«äº† client çš„å®ç°ï¼Œå®ƒå’Œæˆ‘ä»¬å®šä¹‰çš„ idl ä¹Ÿæ˜¯å»åˆçš„
protobuf ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç service OrderManagement {
  rpc getOrder(google.protobuf.StringValue) returns (Order);
}

go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç type orderManagementClient struct {
	cc grpc.ClientConnInterface
}

func NewOrderManagementClient(cc grpc.ClientConnInterface) OrderManagementClient {
	return &orderManagementClient{cc}
}

func (c *orderManagementClient) GetOrder(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*Order, error) {
	out := new(Order)
	err := c.cc.Invoke(ctx, "/ecommerce.OrderManagement/getOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

2ã€ç›´æ¥ä½¿ç”¨ client æ¥è¿›è¡Œ rpc è°ƒç”¨
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç package main

import (
	"context"
	"log"
	"time"

	pb "github.com/liangwt/note/grpc/unary_rpc_example/ecommerce"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

func main() {
	conn, err := grpc.Dial("127.0.0.1:8009", grpc.WithInsecure())
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	client := pb.NewOrderManagementClient(conn)

	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	// Get Order
	retrievedOrder, err := client.GetOrder(ctx, &wrapperspb.StringValue{Value: "101"})
	if err != nil {
		panic(err)
	}

	log.Print("GetOrder Response -> : ", retrievedOrder)
}

å®¢æˆ·ç«¯ä»£ç å®ç°çš„æµç¨‹å¦‚ä¸‹

å°æ€»ç»“
âœ¨ å‰æ–‡æåˆ°è¿‡protobufåè®®æ˜¯å¹³å°æ— å…³çš„ã€‚æ¼”ç¤ºçš„å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯éƒ½æ˜¯ golang çš„ï¼Œå³ä½¿å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¸åŒè¯­è¨€ä¹Ÿæ˜¯ç±»ä¼¼çš„å¯ä»¥é€šä¿¡çš„
âœ¨ å¯¹äºä¸Šé¢ä»‹ç»çš„çš„è¿™ç§ç±»ä¼¼äºhttp1.xçš„æ¨¡å¼ï¼šå®¢æˆ·ç«¯å‘é€è¯·æ±‚ï¼ŒæœåŠ¡ç«¯å“åº”è¯·æ±‚ï¼Œä¸€é—®ä¸€ç­”çš„æ¨¡å¼åœ¨ gRPC é‡Œå«åšSimple RPC (ä¹Ÿç§°Unary RPC)ã€‚gRPC åŒæ—¶ä¹Ÿæ”¯æŒå…¶ä»–ç±»å‹çš„äº¤äº’æ–¹å¼ã€‚

Server-Streaming RPC æœåŠ¡å™¨ç«¯æµå¼ RPC
æœåŠ¡å™¨ç«¯æµå¼ RPCï¼Œæ˜¾ç„¶æ˜¯å•å‘æµï¼Œå¹¶ä»£æŒ‡ Server ä¸º Stream è€Œ Client ä¸ºæ™®é€š RPC è¯·æ±‚
ç®€å•æ¥è®²å°±æ˜¯å®¢æˆ·ç«¯å‘èµ·ä¸€æ¬¡æ™®é€šçš„ RPC è¯·æ±‚ï¼ŒæœåŠ¡ç«¯é€šè¿‡æµå¼å“åº”å¤šæ¬¡å‘é€æ•°æ®é›†ï¼Œå®¢æˆ·ç«¯ Recv æ¥æ”¶æ•°æ®é›†ã€‚å¤§è‡´å¦‚å›¾ï¼š

pb å®šä¹‰
protobuf ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç syntax = "proto3";

package ecommerce;

option go_package = "ecommerce/";

import "google/protobuf/wrappers.proto";

message Order {
  string id = 1;
  repeated string items = 2;
  string description = 3;
  float price = 4;
  string destination = 5;
}

service OrderManagement {
  rpc searchOrders(google.protobuf.StringValue) returns (stream Order);
}

server å®ç°
âœ¨ æ³¨æ„ä¸Simple RPCçš„åŒºåˆ«ï¼šå› ä¸ºæˆ‘ä»¬çš„æœåŠ¡ç«¯æ˜¯æµå¼å“åº”çš„ï¼Œå› æ­¤å¯¹äºæœåŠ¡ç«¯æ¥è¯´å‡½æ•°å…¥å‚å¤šäº†ä¸€ä¸ªstream OrderManagement_SearchOrdersServerå‚æ•°ç”¨æ¥å†™å…¥å¤šä¸ªå“åº”ï¼Œå¯ä»¥æŠŠå®ƒçœ‹ä½œæ˜¯å®¢æˆ·ç«¯çš„å¯¹è±¡
âœ¨ å¯ä»¥é€šè¿‡è°ƒç”¨è¿™ä¸ªæµå¯¹è±¡çš„Send(...)ï¼Œæ¥å¾€å®¢æˆ·ç«¯å†™å…¥æ•°æ®
âœ¨ é€šè¿‡è¿”å›nilæˆ–è€…erroræ¥è¡¨ç¤ºå…¨éƒ¨æ•°æ®å†™å®Œäº†
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç func (s *server) SearchOrders(query *wrapperspb.StringValue,
                              stream pb.OrderManagement_SearchOrdersServer) error {
	for _, order := range orders {
		for _, str := range order.Items {
			if strings.Contains(str, query.Value) {
				err := stream.Send(&order)
				if err != nil {
					return fmt.Errorf("error send: %v", err)
				}
			}
		}
	}

	return nil
}

client å®ç°
âœ¨ æ³¨æ„ä¸Simple RPCçš„åŒºåˆ«ï¼šå› ä¸ºæˆ‘ä»¬çš„æœåŠ¡ç«¯æ˜¯æµå¼å“åº”çš„ï¼Œå› æ­¤ RPC å‡½æ•°è¿”å›å€¼streamæ˜¯ä¸€ä¸ªæµï¼Œå¯ä»¥æŠŠå®ƒçœ‹ä½œæ˜¯æœåŠ¡ç«¯çš„å¯¹è±¡
âœ¨ ä½¿ç”¨streamçš„Recvå‡½æ•°æ¥ä¸æ–­ä»æœåŠ¡ç«¯æ¥æ”¶æ•°æ®
âœ¨ å½“Recvè¿”å›io.EOFä»£è¡¨æµå·²ç»ç»“æŸ
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç c := pb.NewOrderManagementClient(conn)
ctx, cancelFn := context.WithCancel(context.Background())
defer cancelFn()

stream, err := c.SearchOrders(ctx, &wrapperspb.StringValue{Value: "Google"})
if err != nil{
  panic(err)
}

for{
  order, err := stream.Recv()
  if err == io.EOF{
    break
  }

  log.Println("Search Result: ", order)
}

å°æ€»ç»“

Client-Streaming RPC å®¢æˆ·ç«¯æµå¼ RPC
å®¢æˆ·ç«¯æµå¼ RPCï¼Œæ˜¾ç„¶ä¹Ÿæ˜¯å•å‘æµï¼Œå®¢æˆ·ç«¯é€šè¿‡æµå¼å‘èµ·å¤šæ¬¡ RPC è¯·æ±‚ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯å‘èµ·ä¸€æ¬¡å“åº”ç»™å®¢æˆ·ç«¯ï¼Œå¤§è‡´å¦‚å›¾ï¼š
æœåŠ¡ç«¯æ²¡æœ‰å¿…è¦ç­‰åˆ°å®¢æˆ·ç«¯å‘é€å®Œæ‰€æœ‰è¯·æ±‚å†å“åº”ï¼Œå¯ä»¥åœ¨æ”¶åˆ°éƒ¨åˆ†è¯·æ±‚ä¹‹åå°±å“åº”

pb å®šä¹‰
protobuf ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç syntax = "proto3";

package ecommerce;

option go_package = "ecommerce/";

import "google/protobuf/wrappers.proto";

message Order {
  string id = 1;
  repeated string items = 2;
  string description = 3;
  float price = 4;
  string destination = 5;
}

service OrderManagement {
  rpc updateOrders(stream Order) returns (google.protobuf.StringValue);
}

server å®ç°
âœ¨ æ³¨æ„ä¸Simple RPCçš„åŒºåˆ«ï¼šå› ä¸ºæˆ‘ä»¬çš„å®¢æˆ·ç«¯æ˜¯æµå¼è¯·æ±‚çš„ï¼Œå› æ­¤è¯·æ±‚å‚æ•°stream OrderManagement_UpdateOrdersServerå°±æ˜¯æµå¯¹è±¡
âœ¨ å¯ä»¥ä»stream OrderManagement_UpdateOrdersServerçš„Recvå‡½æ•°è¯»å–æ¶ˆæ¯
âœ¨ å½“Recvè¿”å›io.EOFä»£è¡¨æµå·²ç»ç»“æŸ
âœ¨ ä½¿ç”¨stream OrderManagement_UpdateOrdersServerçš„SendAndCloseå‡½æ•°å…³é—­å¹¶å‘é€å“åº”
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç // åœ¨è¿™æ®µç¨‹åºä¸­ï¼Œæˆ‘ä»¬å¯¹æ¯ä¸€ä¸ª Recv éƒ½è¿›è¡Œäº†å¤„ç†
// å½“å‘ç° io.EOF (æµå…³é—­) åï¼Œéœ€è¦å°†æœ€ç»ˆçš„å“åº”ç»“æœå‘é€ç»™å®¢æˆ·ç«¯ï¼ŒåŒæ—¶å…³é—­æ­£åœ¨å¦å¤–ä¸€ä¾§ç­‰å¾…çš„ Recv
func (s *server) UpdateOrders(stream pb.OrderManagement_UpdateOrdersServer) error {
	ordersStr := "Updated Order IDs : "
	for {
		order, err := stream.Recv()
		if err == io.EOF {
			// Finished reading the order stream.
			return stream.SendAndClose(
				&wrapperspb.StringValue{Value: "Orders processed " + ordersStr})
		}
		// Update order
		orders[order.Id] = *order

		log.Println("Order ID ", order.Id, ": Updated")
		ordersStr += order.Id + ", "
	}
}

Client å®ç°
âœ¨ æ³¨æ„ä¸Simple RPCçš„åŒºåˆ«ï¼šå› ä¸ºæˆ‘ä»¬çš„å®¢æˆ·ç«¯æ˜¯æµå¼å“åº”çš„ï¼Œå› æ­¤ RPC å‡½æ•°è¿”å›å€¼streamæ˜¯ä¸€ä¸ªæµ
âœ¨ å¯ä»¥é€šè¿‡è°ƒç”¨è¿™ä¸ªæµå¯¹è±¡çš„Send(...)ï¼Œæ¥å¾€è¿™ä¸ªå¯¹è±¡å†™å…¥æ•°æ®
âœ¨ ä½¿ç”¨streamçš„CloseAndRecvå‡½æ•°å…³é—­å¹¶å‘é€å“åº”
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç c := pb.NewOrderManagementClient(conn)
ctx, cancelFn := context.WithCancel(context.Background())
defer cancelFn()

stream, err := c.UpdateOrders(ctx)
if err != nil {
  panic(err)
}

if err := stream.Send(&pb.Order{
  Id:          "00",
  Items:       []string{"A", "B"},
  Description: "A with B",
  Price:       0.11,
  Destination: "ABC",
}); err != nil {
  panic(err)
}

if err := stream.Send(&pb.Order{
  Id:          "01",
  Items:       []string{"C", "D"},
  Description: "C with D",
  Price:       1.11,
  Destination: "ABCDEFG",
}); err != nil {
  panic(err)
}

res, err := stream.CloseAndRecv()
if err != nil {
  panic(err)
}

log.Printf("Update Orders Res : %s", res)

å°æ€»ç»“

Bidirectional-Streaming RPC åŒå‘æµå¼ RPC
åŒå‘æµå¼ RPCï¼Œé¡¾åæ€ä¹‰æ˜¯åŒå‘æµã€‚ç”±å®¢æˆ·ç«¯ä»¥æµå¼çš„æ–¹å¼å‘èµ·è¯·æ±‚ï¼ŒæœåŠ¡ç«¯åŒæ ·ä»¥æµå¼çš„æ–¹å¼å“åº”è¯·æ±‚
é¦–ä¸ªè¯·æ±‚ä¸€å®šæ˜¯ Client å‘èµ·ï¼Œä½†å…·ä½“äº¤äº’æ–¹å¼ï¼ˆè°å…ˆè°åã€ä¸€æ¬¡å‘å¤šå°‘ã€å“åº”å¤šå°‘ã€ä»€ä¹ˆæ—¶å€™å…³é—­ï¼‰æ ¹æ®ç¨‹åºç¼–å†™çš„æ–¹å¼æ¥ç¡®å®šï¼ˆå¯ä»¥ç»“åˆåç¨‹ï¼‰
å‡è®¾è¯¥åŒå‘æµæ˜¯æŒ‰é¡ºåºå‘é€çš„è¯ï¼Œå¤§è‡´å¦‚å›¾ï¼š

pb å®šä¹‰
protobuf ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç syntax = "proto3";

package ecommerce;

option go_package = "ecommerce/";

import "google/protobuf/wrappers.proto";

message Order {
  string id = 1;
  repeated string items = 2;
  string description = 3;
  float price = 4;
  string destination = 5;
}

message CombinedShipment {
  string id = 1;
  string status = 2;
  repeated Order orderList = 3;
}

service OrderManagement {
  rpc processOrders(stream google.protobuf.StringValue)
      returns (stream CombinedShipment);
}

server å®ç°
âœ¨ å‡½æ•°å…¥å‚OrderManagement_ProcessOrdersServeræ˜¯ç”¨æ¥å†™å…¥å¤šä¸ªå“åº”å’Œè¯»å–å¤šä¸ªæ¶ˆæ¯çš„å¯¹è±¡å¼•ç”¨
âœ¨ å¯ä»¥é€šè¿‡è°ƒç”¨è¿™ä¸ªæµå¯¹è±¡çš„Send(...)ï¼Œæ¥å¾€è¿™ä¸ªå¯¹è±¡å†™å…¥å“åº”
âœ¨ å¯ä»¥é€šè¿‡è°ƒç”¨è¿™ä¸ªæµå¯¹è±¡çš„Recv(...)å‡½æ•°è¯»å–æ¶ˆæ¯ï¼Œå½“Recvè¿”å›io.EOFä»£è¡¨æµå·²ç»ç»“æŸ
âœ¨ é€šè¿‡è¿”å›nilæˆ–è€…errorè¡¨ç¤ºå…¨éƒ¨æ•°æ®å†™å®Œäº†
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç func (s *server) ProcessOrders(stream pb.OrderManagement_ProcessOrdersServer) error {

	batchMarker := 1
	var combinedShipmentMap = make(map[string]pb.CombinedShipment)
	for {
		orderId, err := stream.Recv()
		log.Printf("Reading Proc order : %s", orderId)
		if err == io.EOF {
			log.Printf("EOF : %s", orderId)
			for _, shipment := range combinedShipmentMap {
				if err := stream.Send(&shipment); err != nil {
					return err
				}
			}
			return nil
		}
		if err != nil {
			log.Println(err)
			return err
		}

		destination := orders[orderId.GetValue()].Destination
		shipment, found := combinedShipmentMap[destination]

		if found {
			ord := orders[orderId.GetValue()]
			shipment.OrderList = append(shipment.OrderList, &ord)
			combinedShipmentMap[destination] = shipment
		} else {
			comShip := pb.CombinedShipment{Id: "cmb - " + (orders[orderId.GetValue()].Destination), Status: "Processed!"}
			ord := orders[orderId.GetValue()]
			comShip.OrderList = append(shipment.OrderList, &ord)
			combinedShipmentMap[destination] = comShip
			log.Print(len(comShip.OrderList), comShip.GetId())
		}

		if batchMarker == orderBatchSize {
			for _, comb := range combinedShipmentMap {
				log.Printf("Shipping : %v -> %v", comb.Id, len(comb.OrderList))
				if err := stream.Send(&comb); err != nil {
					return err
				}
			}
			batchMarker = 0
			combinedShipmentMap = make(map[string]pb.CombinedShipment)
		} else {
			batchMarker++
		}
	}
}

Client å®ç°
âœ¨ å‡½æ•°è¿”å›å€¼OrderManagement_ProcessOrdersClientæ˜¯ç”¨æ¥è·å–å¤šä¸ªå“åº”å’Œå†™å…¥å¤šä¸ªæ¶ˆæ¯çš„å¯¹è±¡å¼•ç”¨
âœ¨ å¯ä»¥é€šè¿‡è°ƒç”¨è¿™ä¸ªæµå¯¹è±¡çš„Send(...)ï¼Œæ¥å¾€è¿™ä¸ªå¯¹è±¡å†™å…¥å“åº”
âœ¨ å¯ä»¥é€šè¿‡è°ƒç”¨è¿™ä¸ªæµå¯¹è±¡çš„Recv(...)å‡½æ•°è¯»å–æ¶ˆæ¯ï¼Œå½“Recvè¿”å›io.EOFä»£è¡¨æµå·²ç»ç»“æŸ
go ä½“éªŒAIä»£ç åŠ©æ‰‹ ä»£ç è§£è¯»å¤åˆ¶ä»£ç c := pb.NewOrderManagementClient(conn)
ctx, cancelFn := context.WithCancel(context.Background())
defer cancelFn()

stream, err := c.ProcessOrders(ctx)
if err != nil {
  panic(err)
}

go func() {
  if err := stream.Send(&wrapperspb.StringValue{Value: "101"}); err != nil {
    panic(err)
  }

  if err := stream.Send(&wrapperspb.StringValue{Value: "102"}); err != nil {
    panic(err)
  }

  if err := stream.CloseSend(); err != nil {
    panic(err)
  }
}()

for {
  combinedShipment, err := stream.Recv()
  if err == io.EOF {
    break
  }
  log.Println("Combined shipment : ", combinedShipment.OrderList)
}

å°æ€»ç»“
åŒå‘æµç›¸å¯¹è¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œå¤§éƒ¨åˆ†åœºæ™¯éƒ½æ˜¯ä½¿ç”¨äº‹ä»¶æœºåˆ¶è¿›è¡Œå¼‚æ­¥äº¤äº’ï¼Œéœ€è¦ç²¾å¿ƒçš„è®¾è®¡

ç¤ºä¾‹ä»£ç 

ä½œè€…ï¼šå‡‰å‡‰çš„çŸ¥è¯†åº“
é“¾æ¥ï¼šhttps://juejin.cn/post/7192793369523781691
æ¥æºï¼šç¨€åœŸæ˜é‡‘
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
