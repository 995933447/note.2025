ÊµãËØï‰ª£Á†Å
ÊúçÂä°Á´ØÔºö
package main

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"time"

	"github.com/95933447/grpcgateway/example/client/echo"
	"github.com/995933447/microgosuit"
	"github.com/995933447/microgosuit/discovery"
	"github.com/995933447/microgosuit/grpcsuit"
	"google.golang.org/grpc"
)

func main() {
	err := microgosuit.InitSuitWithGrpc(context.TODO(), "../meta.json", "testschema", "test_discovery")
	if err != nil {
		panic(err)
	}

	err = microgosuit.ServeGrpc(context.TODO(), &microgosuit.ServeGrpcReq{
		RegDiscoverKeyPrefix: "test_discovery",
		SrvName:              "echo.Echo",
		IpVar:                "$inner_ip",
		Port:                 9111,
		RegisterCustomServiceServerFunc: func(server *grpc.Server) error {
			echo.RegisterEchoServer(server, &EchoService{})
			return nil
		},
		AfterRegDiscover: func(discovery discovery.Discovery, node *discovery.Node) error {
			fmt.Printf("======\nrun echo service success.\nhost:%s\nprot:%d\n======\n", node.Host, node.Port)
			return nil
		},
	})
	if err != nil {
		panic(err)
	}
}

type EchoService struct {
	echo.UnimplementedEchoServer
}

func (s *EchoService) BasicEcho(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	var resp echo.EchoResp
	time.Sleep(time.Second)
	resp.Echo = req.Echo
	return &resp, nil
}

func (s *EchoService) InnerEcho(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	return s.BasicEcho(ctx, req)
}

func (s *EchoService) NoAuthEcho(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	return s.BasicEcho(ctx, req)
}

func (s *EchoService) NoAuthEchoErr(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	r := rand.Intn(100)
	if r > 50 {
		return nil, errors.New("sys err")
	}
	return nil, grpcsuit.NewRpcErr(echo.ErrCode_ErrFail)
}


ÊµãËØïÂÆ¢Êà∑Á´Ø‰ª£Á†Å:
package main

import (
	"context"
	"sync"
	"testing"
	"time"

	"github.com/95933447/grpcgateway/example/client/echo"
	"google.golang.org/grpc"
)

func TestBenchEcho(t *testing.T) {
	conn, err := grpc.NewClient("192.168.2.225:9111", grpc.WithInsecure())
	if err != nil {
		panic(err)
	}

	start := time.Now()
	var wg sync.WaitGroup
	for i := 0; i < 10000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			_, err = echo.NewEchoClient(conn).BasicEcho(context.TODO(), &echo.EchoReq{
				Echo: "hello world",
			})
			if err != nil {
				panic(err)
			}
		}()
	}
	wg.Wait()

	// 10000Âπ∂Âèë time elapsed: 1.188055666s ÊâÄ‰ª•grpcÁöÑÂçï‰∏™ÊµÅÁöÑÊúÄÂ§ßÂπ∂ÂèëÈôêÂà∂ÈªòËÆ§‰∏çÊòØÂ¶ÇÁΩë‰∏äÊâÄËØ¥ÁöÑ100
	t.Logf("time elapsed: %s\n", time.Since(start))
}

Ôºàgoogle.golang.org/grpcÔºâÊúçÂä°Á´ØÈªòËÆ§ SETTINGS_MAX_CONCURRENT_STREAMS ÊòØ 2¬π‚Å∂‚àí1Ôºà65535Ôºâ„ÄÇ
üëâ ‰πüÂ∞±ÊòØËØ¥Ôºö

Âπ∂‰∏çÊòØ 100ÔºåËÄåÊòØ 65535 ‰∏™ stream ÂèØ‰ª•ÂêåÊó∂Âπ∂Âèë„ÄÇ

ÊâÄ‰ª• 10000 ‰∏™ËØ∑Ê±ÇÂÖ®ÈÉ®ÂêåÊó∂Ë∑ëËµ∑Êù•‰∫Ü„ÄÇ
Âú® gRPC-Go ÁöÑÂÆûÁé∞ÈáåÔºö

ÊúçÂä°Á´ØÈªòËÆ§ grpc.MaxConcurrentStreams = math.MaxUint32 (‚âà 4 billion)Ôºå‰ΩÜÂÆûÈôÖÂèó HTTP/2 ËßÑËåÉÈôêÂà∂ÔºåÊúÄÁªàÂèëÁªôÂÆ¢Êà∑Á´ØÁöÑÂÄºÊòØ 65535„ÄÇ

ÂÆ¢Êà∑Á´ØÂè™ÈÅµÂÆàÊúçÂä°Á´Ø‰∏ãÂèëÁöÑ SETTINGS_MAX_CONCURRENT_STREAMSÔºåÂπ∂‰∏ç‰ºöËá™Â∑±È¢ùÂ§ñÈôêÂà∂Âà∞ 100„ÄÇ

Âõ†Ê≠§Ôºö

ÊØè‰∏™ËØ∑Ê±Ç time.Sleep(1s) ‚Üí ÂÖ®ÈÉ®ËØ∑Ê±ÇÂá†‰πéÂêåÊó∂ÂºÄÂßã„ÄÅÂêåÊó∂ÁªìÊùü„ÄÇ

ÁªìÊûúÂ∞±ÊòØ Êï¥‰ΩìËÄóÊó∂ ‚âà 1s„ÄÇ

‰ªéÊ∫êÁ†ÅÁúãÂÆ¢Êà∑Á´ØËÆæÁΩÆ‰∫ÜÊúÄÂ§ßÂπ∂Âèë100Ôºå‰∏∫‰ªÄ‰πà‰∏çÁîüÊïàÔºü
ÂÆ¢Êà∑Á´ØÊ∫êÁ†ÅÔºö
// NewHTTP2Client constructs a connected ClientTransport to addr based on HTTP2
// and starts to receive messages on it. Non-nil error returns if construction
// fails.
func NewHTTP2Client(connectCtx, ctx context.Context, addr resolver.Address, opts ConnectOptions, onClose func(GoAwayReason)) (_ ClientTransport, err error) {
	scheme := "http"
	ctx, cancel := context.WithCancel(ctx)
	defer func() {
		if err != nil {
			cancel()
		}
	}()

	// gRPC, resolver, balancer etc. can specify arbitrary data in the
	// Attributes field of resolver.Address, which is shoved into connectCtx
	// and passed to the dialer and credential handshaker. This makes it possible for
	// address specific arbitrary data to reach custom dialers and credential handshakers.
	connectCtx = icredentials.NewClientHandshakeInfoContext(connectCtx, credentials.ClientHandshakeInfo{Attributes: addr.Attributes})

	conn, err := dial(connectCtx, opts.Dialer, addr, opts.UserAgent)
	if err != nil {
		if opts.FailOnNonTempDialError {
			return nil, connectionErrorf(isTemporary(err), err, "transport: error while dialing: %v", err)
		}
		return nil, connectionErrorf(true, err, "transport: Error while dialing: %v", err)
	}

	// Any further errors will close the underlying connection
	defer func(conn net.Conn) {
		if err != nil {
			conn.Close()
		}
	}(conn)

	// The following defer and goroutine monitor the connectCtx for cancellation
	// and deadline.  On context expiration, the connection is hard closed and
	// this function will naturally fail as a result.  Otherwise, the defer
	// waits for the goroutine to exit to prevent the context from being
	// monitored (and to prevent the connection from ever being closed) after
	// returning from this function.
	ctxMonitorDone := grpcsync.NewEvent()
	newClientCtx, newClientDone := context.WithCancel(connectCtx)
	defer func() {
		newClientDone()         // Awaken the goroutine below if connectCtx hasn't expired.
		<-ctxMonitorDone.Done() // Wait for the goroutine below to exit.
	}()
	go func(conn net.Conn) {
		defer ctxMonitorDone.Fire() // Signal this goroutine has exited.
		<-newClientCtx.Done()       // Block until connectCtx expires or the defer above executes.
		if err := connectCtx.Err(); err != nil {
			// connectCtx expired before exiting the function.  Hard close the connection.
			if logger.V(logLevel) {
				logger.Infof("Aborting due to connect deadline expiring: %v", err)
			}
			conn.Close()
		}
	}(conn)

	kp := opts.KeepaliveParams
	// Validate keepalive parameters.
	if kp.Time == 0 {
		kp.Time = defaultClientKeepaliveTime
	}
	if kp.Timeout == 0 {
		kp.Timeout = defaultClientKeepaliveTimeout
	}
	keepaliveEnabled := false
	if kp.Time != infinity {
		if err = isyscall.SetTCPUserTimeout(conn, kp.Timeout); err != nil {
			return nil, connectionErrorf(false, err, "transport: failed to set TCP_USER_TIMEOUT: %v", err)
		}
		keepaliveEnabled = true
	}
	var (
		isSecure bool
		authInfo credentials.AuthInfo
	)
	transportCreds := opts.TransportCredentials
	perRPCCreds := opts.PerRPCCredentials

	if b := opts.CredsBundle; b != nil {
		if t := b.TransportCredentials(); t != nil {
			transportCreds = t
		}
		if t := b.PerRPCCredentials(); t != nil {
			perRPCCreds = append(perRPCCreds, t)
		}
	}
	if transportCreds != nil {
		conn, authInfo, err = transportCreds.ClientHandshake(connectCtx, addr.ServerName, conn)
		if err != nil {
			return nil, connectionErrorf(isTemporary(err), err, "transport: authentication handshake failed: %v", err)
		}
		for _, cd := range perRPCCreds {
			if cd.RequireTransportSecurity() {
				if ci, ok := authInfo.(interface {
					GetCommonAuthInfo() credentials.CommonAuthInfo
				}); ok {
					secLevel := ci.GetCommonAuthInfo().SecurityLevel
					if secLevel != credentials.InvalidSecurityLevel && secLevel < credentials.PrivacyAndIntegrity {
						return nil, connectionErrorf(true, nil, "transport: cannot send secure credentials on an insecure connection")
					}
				}
			}
		}
		isSecure = true
		if transportCreds.Info().SecurityProtocol == "tls" {
			scheme = "https"
		}
	}
	icwz := int32(initialWindowSize)
	if opts.InitialConnWindowSize >= defaultWindowSize {
		icwz = opts.InitialConnWindowSize
	}
	writeBufSize := opts.WriteBufferSize
	readBufSize := opts.ReadBufferSize
	maxHeaderListSize := defaultClientMaxHeaderListSize
	if opts.MaxHeaderListSize != nil {
		maxHeaderListSize = *opts.MaxHeaderListSize
	}

	t := &http2Client{
		ctx:                   ctx,
		ctxDone:               ctx.Done(), // Cache Done chan.
		cancel:                cancel,
		userAgent:             opts.UserAgent,
		registeredCompressors: grpcutil.RegisteredCompressors(),
		address:               addr,
		conn:                  conn,
		remoteAddr:            conn.RemoteAddr(),
		localAddr:             conn.LocalAddr(),
		authInfo:              authInfo,
		readerDone:            make(chan struct{}),
		writerDone:            make(chan struct{}),
		goAway:                make(chan struct{}),
		keepaliveDone:         make(chan struct{}),
		framer:                newFramer(conn, writeBufSize, readBufSize, opts.SharedWriteBuffer, maxHeaderListSize),
		fc:                    &trInFlow{limit: uint32(icwz)},
		scheme:                scheme,
		activeStreams:         make(map[uint32]*ClientStream),
		isSecure:              isSecure,
		perRPCCreds:           perRPCCreds,
		kp:                    kp,
		statsHandlers:         opts.StatsHandlers,
		initialWindowSize:     initialWindowSize,
		nextID:                1,
		maxConcurrentStreams:  defaultMaxStreamsClient,
		streamQuota:           defaultMaxStreamsClient,
		streamsQuotaAvailable: make(chan struct{}, 1),
		keepaliveEnabled:      keepaliveEnabled,
		bufferPool:            opts.BufferPool,
		onClose:               onClose,
	}
	var czSecurity credentials.ChannelzSecurityValue
	if au, ok := authInfo.(credentials.ChannelzSecurityInfo); ok {
		czSecurity = au.GetSecurityValue()
	}
	t.channelz = channelz.RegisterSocket(
		&channelz.Socket{
			SocketType:       channelz.SocketTypeNormal,
			Parent:           opts.ChannelzParent,
			SocketMetrics:    channelz.SocketMetrics{},
			EphemeralMetrics: t.socketMetrics,
			LocalAddr:        t.localAddr,
			RemoteAddr:       t.remoteAddr,
			SocketOptions:    channelz.GetSocketOption(t.conn),
			Security:         czSecurity,
		})
	t.logger = prefixLoggerForClientTransport(t)
	// Add peer information to the http2client context.
	t.ctx = peer.NewContext(t.ctx, t.getPeer())

	if md, ok := addr.Metadata.(*metadata.MD); ok {
		t.md = *md
	} else if md := imetadata.Get(addr); md != nil {
		t.md = md
	}
	t.controlBuf = newControlBuffer(t.ctxDone)
	if opts.InitialWindowSize >= defaultWindowSize {
		t.initialWindowSize = opts.InitialWindowSize
	}
	if !opts.StaticWindowSize {
		t.bdpEst = &bdpEstimator{
			bdp:               initialWindowSize,
			updateFlowControl: t.updateFlowControl,
		}
	}
	for _, sh := range t.statsHandlers {
		t.ctx = sh.TagConn(t.ctx, &stats.ConnTagInfo{
			RemoteAddr: t.remoteAddr,
			LocalAddr:  t.localAddr,
		})
		connBegin := &stats.ConnBegin{
			Client: true,
		}
		sh.HandleConn(t.ctx, connBegin)
	}
	if t.keepaliveEnabled {
		t.kpDormancyCond = sync.NewCond(&t.mu)
		go t.keepalive()
	}

	// Start the reader goroutine for incoming messages. Each transport has a
	// dedicated goroutine which reads HTTP2 frames from the network. Then it
	// dispatches the frame to the corresponding stream entity.  When the
	// server preface is received, readerErrCh is closed.  If an error occurs
	// first, an error is pushed to the channel.  This must be checked before
	// returning from this function.
	readerErrCh := make(chan error, 1)
	go t.reader(readerErrCh)
	defer func() {
		if err != nil {
			// writerDone should be closed since the loopy goroutine
			// wouldn't have started in the case this function returns an error.
			close(t.writerDone)
			t.Close(err)
		}
	}()

	// Send connection preface to server.
	n, err := t.conn.Write(clientPreface)
	if err != nil {
		err = connectionErrorf(true, err, "transport: failed to write client preface: %v", err)
		return nil, err
	}
	if n != len(clientPreface) {
		err = connectionErrorf(true, nil, "transport: preface mismatch, wrote %d bytes; want %d", n, len(clientPreface))
		return nil, err
	}
	var ss []http2.Setting

	if t.initialWindowSize != defaultWindowSize {
		ss = append(ss, http2.Setting{
			ID:  http2.SettingInitialWindowSize,
			Val: uint32(t.initialWindowSize),
		})
	}
	if opts.MaxHeaderListSize != nil {
		ss = append(ss, http2.Setting{
			ID:  http2.SettingMaxHeaderListSize,
			Val: *opts.MaxHeaderListSize,
		})
	}
	err = t.framer.fr.WriteSettings(ss...)
	if err != nil {
		err = connectionErrorf(true, err, "transport: failed to write initial settings frame: %v", err)
		return nil, err
	}
	// Adjust the connection flow control window if needed.
	if delta := uint32(icwz - defaultWindowSize); delta > 0 {
		if err := t.framer.fr.WriteWindowUpdate(0, delta); err != nil {
			err = connectionErrorf(true, err, "transport: failed to write window update: %v", err)
			return nil, err
		}
	}

	t.connectionID = atomic.AddUint64(&clientConnectionCounter, 1)

	if err := t.framer.writer.Flush(); err != nil {
		return nil, err
	}
	// Block until the server preface is received successfully or an error occurs.
	if err = <-readerErrCh; err != nil {
		return nil, err
	}
	go func() {
		t.loopy = newLoopyWriter(clientSide, t.framer, t.controlBuf, t.bdpEst, t.conn, t.logger, t.outgoingGoAwayHandler, t.bufferPool)
		if err := t.loopy.run(); !isIOError(err) {
			// Immediately close the connection, as the loopy writer returns
			// when there are no more active streams and we were draining (the
			// server sent a GOAWAY).  For I/O errors, the reader will hit it
			// after draining any remaining incoming data.
			t.conn.Close()
		}
		close(t.writerDone)
	}()
	return t, nil
}ËøôÊÆµ‰ª£Á†ÅÊòØÂê¶ËØ¥ÊòéÂÆ¢Êà∑Á´Ø‰ºöËá™Â∑±ÊéßÂà∂Âπ∂ÂèëÊï∞Èáè	defaultMaxStreamsClient       = 100

ÁúüÁõ∏Ôºö

1. ‰ª£Á†ÅÈáåÁöÑ defaultMaxStreamsClient = 100
Âú® gRPC-Go (transport/http2_client.go) Á°ÆÂÆûÂÆö‰πâ‰∫ÜËøô‰∏™Â∏∏ÈáèÔºö

go

const defaultMaxStreamsClient = 100
Âú®‰Ω†Ë¥¥ÁöÑ NewHTTP2Client ÈáåÔºåÂÆÉË¢´ËµãÂÄºÁªôÔºö

go

maxConcurrentStreams:  defaultMaxStreamsClient,
streamQuota:           defaultMaxStreamsClient,
ËøôÁúã‰∏äÂéªÂÉèÊòØ‚ÄúÂÆ¢Êà∑Á´ØËá™Â∑±ÈªòËÆ§ÊúÄÂ§öÂè™ËÉΩÂπ∂Âèë 100 ‰∏™ stream‚Äù„ÄÇ

2. ÂÆûÈôÖËøêË°åÊó∂‰ºöÂèëÁîü‰ªÄ‰πàÔºü
Ê≥®ÊÑèÔºöËøôÂè™ÊòØ ÂàùÂßãÂÄºÔºåÂπ∂‰∏çÊòØÊúÄÁªàÂÄº„ÄÇ

ÂΩìÂÆ¢Êà∑Á´ØÂÆåÊàê HTTP/2 SETTINGS ‰∫§Êç¢ ‰πãÂêéÔºåÊúçÂä°Á´Ø‰ºöÂëäËØâÂÆ¢Êà∑Á´ØÔºö
SETTINGS_MAX_CONCURRENT_STREAMS = N

Âú® gRPC-Go ÁöÑ reader goroutine ÈáåÔºåÂΩìÊî∂Âà∞ SETTINGS Â∏ßÊó∂Ôºå‰ºöÊõ¥Êñ∞Ôºö

go
t.maxConcurrentStreams = srvSettings.MaxConcurrentStreams
t.streamQuota = srvSettings.MaxConcurrentStreams
ÊâÄ‰ª•Ôºö

Âú®ËøûÊé•ÂàöÂª∫Á´ãÔºåËøòÊ≤°Êî∂Âà∞ÊúçÂä°Á´Ø SETTINGS ‰πãÂâçÔºåÂÆ¢Êà∑Á´ØÂè™ËÉΩÂºÄ 100 ‰∏™ stream„ÄÇ

‰∏ÄÊó¶Êî∂Âà∞ÊúçÂä°Á´ØÁöÑËÆæÁΩÆÔºåÂ∞±‰ºöË¶ÜÁõñËøô‰∏™ÂÄº„ÄÇ

gRPC-Go ÊúçÂä°Á´ØÈªòËÆ§‰∏ãÂèëÁöÑÊòØ math.MaxUint32 ‚âà 4e9Ôºå‰ΩÜÊòØ‰ºöË¢´ HTTP/2 ÂçèËÆÆËßÑËåÉÈôêÂà∂Âú® 2^31-1ÔºåÊâÄ‰ª•Â∏∏ËßÅÂÄºÊòØ 65535„ÄÇ

3. ÁªìÂêàÂÆûÈ™å
ÂÆ¢Êà∑Á´ØËµ∑‰∫Ü 10000 ‰∏™Âπ∂ÂèëËØ∑Ê±ÇÔºå‰∏ÄÊ¨°Â∞±ÂÖ®Ë∑ëÂÆå‰∫ÜÔºåËÄóÊó∂ 1s„ÄÇ
ËØ¥ÊòéÔºö

ÂÆ¢Êà∑Á´ØÂú®Âª∫Á´ãËøûÊé•ÂêéÂ∑≤ÁªèÊî∂Âà∞‰∫ÜÊúçÂä°Á´ØÁöÑ SETTINGS„ÄÇ

ÊúçÂä°Á´ØÈªòËÆ§ÂÄºÂæàÂ§ßÔºà65535ÔºâÔºåÊâÄ‰ª•ÂÆ¢Êà∑Á´ØÊîæÂºÄ‰∫ÜÈôêÂà∂„ÄÇ

defaultMaxStreamsClient = 100 ÁöÑÂΩ±ÂìçÂè™Â≠òÂú®‰∫é„ÄåÂàöËøû‰∏ä„ÄÅÊ≤°Êè°ÊâãÂÆå„ÄçÁöÑÈÇ£‰∏ÄÁû¨Èó¥„ÄÇ‰Ω†ÊµãÁöÑÊó∂ÂÄôÂ∑≤ÁªèËøá‰∫ÜËøô‰∏ÄÊ≠•ÔºåÊâÄ‰ª• 100 Âπ∂Ê≤°ÊúâËµ∑‰ΩúÁî®„ÄÇ

4. ÁªìËÆ∫
ÂÆ¢Êà∑Á´ØÁ°ÆÂÆûÊúâÈªòËÆ§Âπ∂Âèë‰∏äÈôê 100Ôºå‰ΩÜÂè™ÊòØ ‰∏¥Êó∂ÁöÑ bootstrap ÂÄº„ÄÇ

ÁúüÊ≠£ÂÜ≥ÂÆöÂπ∂Âèë‰∏äÈôêÁöÑÊòØ ÊúçÂä°Á´ØÂèë‰∏ãÊù•ÁöÑ SETTINGS_MAX_CONCURRENT_STREAMS„ÄÇ

gRPC-Go ÊúçÂä°Á´ØÈªòËÆ§ÁªôÂÆ¢Êà∑Á´ØÁöÑÊòØ‰∏Ä‰∏™Â∑®Â§ßÁöÑÊï∞Ôºà65535ÔºâÔºåÊâÄ‰ª•‰Ω†ËÉΩÂπ∂Âèë 300 ÁîöËá≥Êõ¥Â§ö„ÄÇ

‚úÖ ÊÄªÁªì
‰Ω†ÁúãÂà∞ÁöÑ defaultMaxStreamsClient = 100 Âπ∂‰∏çÊòØÂÆ¢Êà∑Á´ØÁöÑÁ°¨ÈôêÂà∂ÔºåËÄåÊòØ„ÄåÊè°ÊâãÂÆåÊàêÂâçÁöÑÂç†‰ΩçÂÄº„Äç„ÄÇ
ÊúÄÁªà‰∏äÈôêÂèñÂÜ≥‰∫éÊúçÂä°Á´Ø ‚Äî‚Äî gRPC-Go ÊúçÂä°Á´ØÈªòËÆ§‰∏ãÂèë 65535ÔºåÊâÄ‰ª•‰Ω†ÂÆûÈ™åÈáåÊ≤°ÊúâË¢´Âç°‰Ωè„ÄÇ

ÂÖ∑‰Ωì‰ª£Á†ÅÂú®ËøôÔºö
func (t *http2Client) handleSettings(f *http2.SettingsFrame, isFirst bool) {
	if f.IsAck() {
		return
	}
	var maxStreams *uint32
	var ss []http2.Setting
	var updateFuncs []func()
	f.ForeachSetting(func(s http2.Setting) error {
		switch s.ID {
		case http2.SettingMaxConcurrentStreams:
			maxStreams = new(uint32)
			*maxStreams = s.Val
		case http2.SettingMaxHeaderListSize:
			updateFuncs = append(updateFuncs, func() {
				t.maxSendHeaderListSize = new(uint32)
				*t.maxSendHeaderListSize = s.Val
			})
		default:
			ss = append(ss, s)
		}
		return nil
	})
	if isFirst && maxStreams == nil {
		maxStreams = new(uint32)
		*maxStreams = math.MaxUint32
	}
	sf := &incomingSettings{
		ss: ss,
	}
	if maxStreams != nil {
		updateStreamQuota := func() {
			delta := int64(*maxStreams) - int64(t.maxConcurrentStreams)
			t.maxConcurrentStreams = *maxStreams
			t.streamQuota += delta
			if delta > 0 && t.waitingStreams > 0 {
				close(t.streamsQuotaAvailable) // wake all of them up.
				t.streamsQuotaAvailable = make(chan struct{}, 1)
			}
		}
		updateFuncs = append(updateFuncs, updateStreamQuota)
	}
	t.controlBuf.executeAndPut(func() bool {
		for _, f := range updateFuncs {
			f()
		}
		return true
	}, sf)
}


ËøôÊÆµ handleSettings Ê≠£ÊòØ ÂÆ¢Êà∑Á´ØÊõ¥Êñ∞Âπ∂Âèë‰∏äÈôê ÁöÑÊ†∏ÂøÉÈÄªËæë„ÄÇÊàë‰ª¨ÊãÜ‰∏Ä‰∏ãÔºö

1. ÂÖ≥ÈîÆÁÇπÔºöhttp2.SettingMaxConcurrentStreams
go

f.ForeachSetting(func(s http2.Setting) error {
    switch s.ID {
    case http2.SettingMaxConcurrentStreams:
        maxStreams = new(uint32)
        *maxStreams = s.Val
ËøôÈáå‰ºöÊçïËé∑ÊúçÂä°Á´Ø‰∏ãÂèëÁöÑ SETTINGS_MAX_CONCURRENT_STREAMS ÂÄº„ÄÇ

2. Â¶ÇÊûúÊòØÁ¨¨‰∏Ä‰∏™ SETTINGSÔºå‰∏îÊúçÂä°Á´ØÊ≤°ÊòæÂºèÁªôÂÄº
go

if isFirst && maxStreams == nil {
    maxStreams = new(uint32)
    *maxStreams = math.MaxUint32
}
üìå ËøôËØ¥ÊòéÔºö

Á¨¨‰∏ÄÊ¨°Êè°ÊâãÂ¶ÇÊûúÊúçÂä°Á´ØÊ≤°ÂëäËØâÂÆ¢Êà∑Á´ØÂπ∂Âèë‰∏äÈôêÔºåÈÇ£ÂÆ¢Êà∑Á´ØÂ∞±ÂÅáËÆæ Êó†ÈôêÂ§ß (2^32-1)„ÄÇ

Ëøô‰πüËß£Èáä‰∫Ü‰∏∫‰ªÄ‰πà‰Ω†ÂÆûÈ™åÈáåËÉΩËΩªÊùæË∂ÖËøá 100 ‚Äî‚Äî gRPC-Go ÊúçÂä°Á´ØÈªòËÆ§‰∏ç‰ºö‰∏ãÂèëÈôêÂà∂„ÄÇ

3. Êõ¥Êñ∞Âπ∂ÂèëÊéßÂà∂
go
updateStreamQuota := func() {
    delta := int64(*maxStreams) - int64(t.maxConcurrentStreams)
    t.maxConcurrentStreams = *maxStreams
    t.streamQuota += delta
    if delta > 0 && t.waitingStreams > 0 {
        close(t.streamsQuotaAvailable) // wake all of them up.
        t.streamsQuotaAvailable = make(chan struct{}, 1)
    }
}
t.maxConcurrentStreamsÔºöÊõ¥Êñ∞‰∏∫Êñ∞ÁöÑÊúÄÂ§ßÂπ∂Âèë„ÄÇ

t.streamQuotaÔºöÂ¢ûÂä†ÂèØÁî®ÁöÑ stream ÈÖçÈ¢ù„ÄÇ

Â¶ÇÊûúÊúâÁ≠âÂæÖ‰∏≠ÁöÑ streamÔºåÂ∞±Ë¢´Âî§ÈÜí„ÄÇ

4. ÁªìÂêàÂâçÈù¢‰Ω†Ë¥¥ÁöÑ defaultMaxStreamsClient = 100
ËøûÊé•ÂàöÂª∫Á´ãÊó∂ÔºåÂÆ¢Êà∑Á´ØÁî® ‰∏¥Êó∂ÂÄº 100 ÈôêÂà∂Âπ∂Âèë„ÄÇ

‰∏ÄÊó¶Êî∂Âà∞ÊúçÂä°Á´Ø SETTINGSÔºåËøôÈáåÁöÑÈÄªËæë‰ºöÁ´ãÂàªË¶ÜÁõñÂÆÉ„ÄÇ

Â¶ÇÊûúÊúçÂä°Á´Ø‰∏çÂèë SETTINGS_MAX_CONCURRENT_STREAMSÔºåÂ∞±Ëµ∞ÈªòËÆ§ÁöÑ math.MaxUint32ÔºàÂá†‰πéÊó†ÈôêÔºâ„ÄÇ

‚úÖ ÁªìËÆ∫
ÊòØÁöÑÔºåÂ∞±ÊòØËøôÊÆµ‰ª£Á†ÅÊéßÂà∂‰∫Ü gRPC ÂÆ¢Êà∑Á´ØÊúÄÁªàËÉΩÂºÄÁöÑÂπ∂ÂèëÊï∞„ÄÇ
defaultMaxStreamsClient = 100 Âè™ÊòØÂàùÂßã bootstrap ÂÄºÔºåÊè°ÊâãÂêé‰ºöË¢´ËøôÈáåÊõøÊç¢ÊéâÔºåÊâÄ‰ª•‰Ω†ÁöÑÂÆûÈ™åÊâçËÉΩË∂ÖËøá 100„ÄÇ

È™åËØÅ‰ª£Á†Å:
ÊúçÂä°Á´ØÔºö
package main

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"time"

	"github.com/95933447/grpcgateway/example/client/echo"
	"github.com/995933447/microgosuit"
	"github.com/995933447/microgosuit/discovery"
	"github.com/995933447/microgosuit/grpcsuit"
	"google.golang.org/grpc"
)

func main() {
	err := microgosuit.InitSuitWithGrpc(context.TODO(), "../meta.json", "testschema", "test_discovery")
	if err != nil {
		panic(err)
	}

	err = microgosuit.ServeGrpc(context.TODO(), &microgosuit.ServeGrpcReq{
		RegDiscoverKeyPrefix: "test_discovery",
		SrvName:              "echo.Echo",
		IpVar:                "$inner_ip",
		Port:                 9111,
		SrvOpts:              []grpc.ServerOption{grpc.MaxConcurrentStreams(10)}, // ÊúçÂä°Âô®ÈôêÂà∂ÊúÄÂ§ßÂπ∂ÂèëÊµÅÊï∞
		RegisterCustomServiceServerFunc: func(server *grpc.Server) error {
			echo.RegisterEchoServer(server, &EchoService{})
			return nil
		},
		AfterRegDiscover: func(discovery discovery.Discovery, node *discovery.Node) error {
			fmt.Printf("======\nrun echo service success.\nhost:%s\nprot:%d\n======\n", node.Host, node.Port)
			return nil
		},
	})
	if err != nil {
		panic(err)
	}
}

type EchoService struct {
	echo.UnimplementedEchoServer
}

func (s *EchoService) BasicEcho(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	var resp echo.EchoResp
	time.Sleep(time.Second)
	resp.Echo = req.Echo
	return &resp, nil
}

func (s *EchoService) InnerEcho(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	return s.BasicEcho(ctx, req)
}

func (s *EchoService) NoAuthEcho(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	return s.BasicEcho(ctx, req)
}

func (s *EchoService) NoAuthEchoErr(ctx context.Context, req *echo.EchoReq) (*echo.EchoResp, error) {
	r := rand.Intn(100)
	if r > 50 {
		return nil, errors.New("sys err")
	}
	return nil, grpcsuit.NewRpcErr(echo.ErrCode_ErrFail)
}

ÂÆ¢Êà∑Á´ØÔºö
package main

import (
	"context"
	"sync"
	"testing"
	"time"

	"github.com/95933447/grpcgateway/example/client/echo"
	"google.golang.org/grpc"
)

func TestBenchEcho(t *testing.T) {
	conn, err := grpc.NewClient("192.168.2.225:9111", grpc.WithInsecure())
	if err != nil {
		panic(err)
	}

	start := time.Now()
	var wg sync.WaitGroup
	for i := 0; i < 30; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			_, err = echo.NewEchoClient(conn).BasicEcho(context.TODO(), &echo.EchoReq{
				Echo: "hello world",
			})
			if err != nil {
				panic(err)
			}
		}()
	}
	wg.Wait()

	// echo_bench_test.go:36: time elapsed: 3.004762791s
	t.Logf("time elapsed: %s\n", time.Since(start))
}

