最近在用 Go 的 gRPC reflection 调试时遇到一个坑，分享一下经验，希望能帮到遇到类似问题的同学。

问题复现



我有一个 echo.proto，里面 import 了 mgorm/ext.proto：

import "mgorm/ext.proto";

service Echo {
  rpc BasicEcho(EchoReq) returns (EchoResp);
}




生成 Go 代码时，使用：

protoc --go_out=. --go-grpc_out=. ./proto/echo.proto




生成的 echo.pb.go 里面有一行：

import _ "github.com/995933447/mgorm/pb"


然后注册反射服务
grpcServer := grpc.NewServer(opts.GRPCServerOpts...)
echo.RegisterEchoServer(server, handler.EchoHandler)
reflection.Register(grpcServer)

在reflection.Register(grpcServer)内部上需要注册服务依赖的ext.proto 的 FileDescriptor的
本意是为了注册 ext.proto 的 FileDescriptor，但实际情况是：

我本地有 ./proto/mgorm/ext.proto
但 import 的包 _ "github.com/995933447/mgorm/pb" 对应的是 第三方仓库里的 proto 文件，路径为 "github.com/995933447/mgorm/proto/ext.proto"



于是，当我写动态网关用 reflection 调用服务：

rpcSvcDesc, err := cli.ResolveService("echo.Echo")


报错：

Service not found: echo.Echo
caused by: File not found: mgorm/ext.proto


解决方法：

修改 ext.proto 的 go_package 为本地项目路径：

option go_package = "github.com/995933447/easymicro/example/ext/mgorm";


重新生成 pb 文件：

protoc --go_out=. --go-grpc_out=. ./proto/echo.proto

自此解决。



核心原因：

echo.pb.go 里生成了：

import _ "github.com/995933447/mgorm/pb"

这只是为了注册 mgorm/ext.proto 的 FileDescriptor。

Go 编译器会去这个路径下的包初始化，但这个包实际上对应的是 第三方仓库里的 proto 文件，而不是本地的 ./proto/mgorm/ext.proto。

proto 文件里写了：

import "mgorm/ext.proto";

reflection 会查找 FileDescriptor 注册的路径 "mgorm/ext.proto"。

但你本地的 echo.pb.go 引入的 _ "github.com/995933447/mgorm/pb" 注册的是第三方 proto 的路径 "github.com/995933447/mgorm/proto/ext.proto"。

两者路径不一致 → reflection 查不到 → Service not found。


修改 go_package 并重新生成：

option go_package = "github.com/995933447/easymicro/example/ext/mgorm";


生成的 echo.pb.go 里 import 的路径和本地 proto 对应的路径一致。

reflection 注册的 FileDescriptor 和本地 proto 的 import 路径匹配 → 问题消失。

结论

gRPC reflection 找 proto 文件不是看文件系统，而是看 Go 包注册的 FileDescriptor 路径是否和 proto import 路径一致。

引用第三方 pb 包（如 github.com/995933447/mgorm/pb）会导致路径不一致问题，尤其当你希望 reflection 访问你本地 proto 文件时。

正确做法：确保 go_package 与本地 proto 的目录结构、生成路径和 import 一致。
