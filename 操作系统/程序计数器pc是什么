pc（Program Counter）代表的是调用位置在可执行文件中的指令地址。

这个地址是函数中某一行的指令位置，也就是说是代码位置，不是 goroutine 或线程相关。

因此，只要是同一行调用，无论在哪个 goroutine 中执行，返回的 pc 都是一样的。

🔍 举个例子说明：
go
复制
编辑
func logCaller() {
    var pcs [1]uintptr
    runtime.Callers(1, pcs[:]) // skip=1：获取调用 logCaller 的位置
    fmt.Printf("goroutine: %d, pc: %x\n", goid.Get(), pcs[0])
}

func main() {
    for i := 0; i < 5; i++ {
        go logCaller()  // 所有 goroutine 在同一行调用 logCaller
    }
    time.Sleep(time.Second)
}
📌 输出示例：

yaml
复制
编辑
goroutine: 19, pc: 0x105872f
goroutine: 20, pc: 0x105872f
goroutine: 21, pc: 0x105872f
...
goroutine 不同

但 pc 相同，因为它们都在 同一行调用 logCaller()

✅ 结论
条件	pc 值是否相同
同一行代码调用	✅ 是
不同 goroutine 中调用	✅ 仍然相同
不同行代码调用	❌ 不同
同一函数中不同位置调用	❌ 不同

🔒 应用场景提示：
如果你用 pc 做 调用位置缓存（例如用于日志 trace），是非常合理的。

缓存粒度就是“代码的某一行”。

和 goroutine 无关。

pc（也就是 程序计数器，Program Counter）它的值取决于：

🧠 程序当前的调用位置（函数 + 行号）
当你调用：

go
复制
编辑
var pcs [1]uintptr
runtime.Callers(skip, pcs[:])
pc := pcs[0]
这个 pc 表示调用栈中某一层函数的指令地址，也就是：

哪个函数

哪一行代码

因此，只要你的调用位置不同，哪怕是同一个函数的不同行，pc 的值也是不同的。

✅ 举个例子：
go
复制
编辑
func test() {
    printPC()  // Line A
    printPC()  // Line B
}

func printPC() {
    var pcs [1]uintptr
    runtime.Callers(1, pcs[:]) // skip = 1, 获取 test() 的调用处
    fmt.Printf("pc: %x\n", pcs[0])
}
输出示例：

makefile
复制
编辑
pc: 0x10563c2
pc: 0x10563e0
👉 两次 printPC() 调用，pc 不一样，因为是在 test() 的不同位置。

📌 但是：
如果你的代码在循环或高并发中从同一个调用点调用 runtime.Callers，那 pc 的值会重复，比如：

go
复制
编辑
for i := 0; i < 10; i++ {
    logSomething() // 同一行调用
}
这时 pc 的值可能是一样的，因为调用点是相同的。

程序计数器是什么(PC) 
引言
在学习操作系统的时候很多时候都可以看到程序计数器的身影，但是对于程序计数器的概念一直是模模糊糊，今天算是弄懂了何为PC,遂记录一篇博客。

程序计数器是什么 PC(program counter)

在百度中找到的解释是这样的：
在CPU控制部件中的程序计数器（PC）的功能是用于存放指令的地址。程序执行时，PC的初值为程序第一条指令的地址，在顺序执行程序时，控制器首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将PC的值加1指向下一条要执行的指令。(侵删)

其实大体的意思就是这样，可是单独的去看这个概念却有些模糊，我们可以先结合三个例子来看什么是PC,PC又是干什么的

一，上下文切换
我们都知道系统为了实现并发，操作系统采取了一种高层形式的异常控制流(ECF) 上下文切换，其基本思想就是在程序遇到阻塞，耗时间的系统调用或中断(周期性定时器中断)时CPU会对当前工作线程进行替换，当这些耗时的操作完成时再进行把跳回前面的程序段，这个跳就很有意思了，用户栈，内核栈，状态寄存器等不用说，数据当然该被记录，但操作系统又如何知道代码运行到哪里呢　这就是程序计数器的作用　我们再来看看程序计数器的含义程序计数器（PC）的功能是用于存放指令的地址 这样一想　便清晰了不少

二，非本地跳转
非本地跳转是一种用户级的异常控制流　其作用与goto类似　但与goto有一点不同　就是非本地跳转可跨函数进行跳转，其实跳转与上下文切换在某种意义上很相像，他们都要把当前状态转化为另外一种状态，这就牵扯到应该执行到哪一条指令的问题，这也是我们程序计数器的作用

三，fork()函数
在　fork　之后父子进行从同一指令开始运行，这是因为子进程拷贝了父进程的程序计数器，而程序计数器的作用是什么，就是存放当前指令　所以就不难理解了。

在三个简单的例子后我们已经大概的理解了程序计数器的作用是什么　接下来我们就来看看程序计数器的处理流程

在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。
2020年5月29日：
其实程序计数器在8086下就是IP寄存器，IA-32下就是EIP寄存器。

它们的作用就是保存一个内存地址，指向当前需要取出的指令，当CPU从内存中取出一个指令以后，EIP/IP就自动增加，指向下一个指令的地址。这样看来上下文切换实际就是寄存器的切换。

参考：

博文《程序计数器（Program Counter）是一个实际存在的寄存器吗？》
博文《程序计数器》
书籍《Computer Systems:A Programmer’s Perspective》

